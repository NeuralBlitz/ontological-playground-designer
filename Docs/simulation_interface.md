# ‚öôÔ∏è Simulation Interface: Bringing Worlds to Life

The **Ontological Playground Designer** creates intricate blueprints for axiomatically aligned worlds. This section details how these blueprints are translated into dynamic, executable simulations, allowing you to observe their emergent behavior, validate their flourishing trajectories, and truly understand the consequences of AI-designed foundational principles.

---

## üí° The Bridge from Design to Reality: `Compiled World Config`

The AI's design process culminates in a `Compiled World Config` (generated by `src/core/world_compiler.py`). This is a structured file (typically JSON or YAML) that serves as the complete blueprint for your simulated world.

It contains:
*   **`world_metadata`**: Information about the design process, axioms used, and creation timestamp.
*   **`simulation_defaults`**: General settings inherited from `config/simulation_settings.yaml` (e.g., world size, max steps).
*   **`generated_world_rules`**: The core, AI-designed rules categorized by type (e.g., `agent_behaviors`, `environmental_laws`, `social_dynamics`). These are the fundamental "physics" of your world.
*   **`rule_interdependencies_graph`**: A representation of how all the generated rules interact and influence each other.

This `Compiled World Config` is the standardized input for any compatible simulation engine.

---

## üîó The Standardized Connection: `SimulatorAdapter`

To maintain flexibility and allow integration with diverse simulation platforms, the system uses a `SimulatorAdapter`.

### `src/simulators/simulator_adapter.py`

*   **Purpose:** To abstract away the specifics of different simulation engines, providing a single, standardized interface for running AI-designed worlds.
*   **How it Works:**
    1.  You initialize the `SimulatorAdapter` specifying the `simulator_type` (e.g., `"template_simulator"`).
    2.  The adapter dynamically loads the appropriate simulator class (e.g., `TemplateSimulator`).
    3.  When you call `adapter.run_world()`, it instantiates that simulator with your `Compiled World Config` and starts the simulation.
*   **Benefits:** This modular design ensures that as new or more complex simulation engines emerge, they can be integrated simply by writing a new adapter module, without altering the core AI design logic.

---

## üî¨ Example Simulation Engine: `TemplateSimulator`

To demonstrate the execution of an AI-designed world, the repository includes a basic agent-based simulator.

### `simulators/template_simulator/template_simulator.py`

*   **Purpose:** To provide a functional example of how `GeneratedWorldRules` are interpreted and translated into dynamic, emergent behavior over simulated time.
*   **Key Features:**
    *   **Initial World State:** Sets up agents and resources based on the `Compiled World Config`'s initial parameters.
    *   **Rule Application Loop:** In each `time_step`:
        *   It iterates through agents, applying AI-designed `agent_behaviors` (e.g., movement, resource consumption, cooperation).
        *   It applies `environmental_laws` to resources (e.g., regeneration rates).
        *   It uses `system_mechanics` (e.g., feedback loops) to adjust global parameters based on world metrics (e.g., average flourishing).
    *   **Output Logging:** Generates a detailed `simulation log file` (JSON Lines format) containing time-series data of the world's evolution (agent states, resource levels, world metrics). This log is crucial for subsequent evaluation and visualization.

---

## üìà Observing Emergent Behavior: `Evaluation` & `Visualization`

Once a world is simulated, the system provides powerful tools to understand its performance and dynamics:

### 1. **Flourishing Evaluation (`src/core/flourishing_evaluator.py`)**

*   **Purpose:** To analyze the `simulation log data` and predict the long-term axiom adherence and ethical flourishing trajectory of the world.
*   **Mechanism:** It processes the time-series data from the simulation log, calculates various metrics (e.g., `total_flourishing_score`, `sustainability_index`, `equity_distribution`), and assesses how well the world adhered to your original `AxiomSet`.
*   **Output:** A `WorldEvaluationReport` that provides quantitative scores, interpretations, and `recommendations` for how to refine the world's design.

### 2. **Conceptual Graph Visualization (`src/visualization/graph_renderer.py`)**

*   **Purpose:** To visually represent the intricate relationships between the AI-designed rules and axioms.
*   **Mechanism:** It takes the `rule_interdependencies_graph` (from the `Compiled World Config`) and renders it as an interactive HTML file. This allows you to explore the complex web of influences and dependencies, which is critical for **Causal Explainability**.

### 3. **World Animation (`src/visualization/world_animator.py` - Placeholder)**

*   **Purpose:** To bring the simulation to life through dynamic, time-series visualizations.
*   **Future Functionality:** This module will eventually interpret the `simulation log data` to create animations (e.g., GIFs, MP4s, interactive web charts) showing how agents move, resources change, and metrics evolve over the world's lifespan, providing an intuitive understanding of its emergent properties.

---

## üõ†Ô∏è Extending to Other Simulators

The `SimulatorAdapter` is designed for easy extensibility. To integrate a new simulation engine:

1.  **Create a New Simulator Module:** In the `simulators/` directory, create a new subdirectory (e.g., `netlogo_adapter/`). Inside, create a Python file (e.g., `netlogo_adapter.py`) that defines a class (e.g., `NetLogoSimulator`).
2.  **Implement Standard Interface:** This new simulator class must have:
    *   An `__init__(self, world_config: Dict[str, Any])` method that takes the `Compiled World Config`.
    *   A `run_simulation(self, output_log_path: str, log_interval: int)` method that executes the simulation and saves time-series log data to the specified path (preferably in JSONL format, similar to `TemplateSimulator`).
3.  **Update `SimulatorAdapter`:** Add an `elif` branch in `src/simulators/simulator_adapter.py`'s `_load_simulator_class()` method to dynamically import and reference your new simulator.
4.  **Update Configuration:** If your simulator requires specific parameters, add them to `config/simulation_settings.yaml`.

This allows the Ontological Playground Designer to leverage a growing ecosystem of simulation technologies, perpetually expanding its capacity for **Unbounded Manifestation ($\phi_{\text{UM}}^{2.0}$)**.

---

