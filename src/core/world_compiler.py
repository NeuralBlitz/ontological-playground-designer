# ontological-playground-designer/src/core/world_compiler.py

import yaml
import json
import os
from typing import Dict, Any, Optional

# Ensure loguru is set up for structured logging
from loguru import logger
from src.utils.logger import setup_logging

# Import GeneratedWorldRules from rule_generator for type hinting
from src.core.rule_generator import GeneratedWorldRules

# Setup logging for this module
setup_logging()

class WorldCompiler:
    """
    Translates the abstract rules and parameters generated by the RuleGenerator
    into a concrete, machine-readable simulation configuration file (e.g., JSON).

    This class bridges the gap between the AI's high-level design and
    a runnable simulation. It ensures the "ontological blueprint"
    is precisely translated into the "physical laws" of the simulated world.
    """
    def __init__(self, simulation_settings_path: str = "config/simulation_settings.yaml"):
        """
        Initializes the WorldCompiler, loading default simulation settings.

        Args:
            simulation_settings_path (str): Path to the generic simulation settings YAML.
        """
        self.simulation_settings: Dict[str, Any] = self._load_config(simulation_settings_path)
        logger.info("WorldCompiler initialized.")

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Loads a YAML configuration file."""
        if not os.path.exists(config_path):
            logger.error(f"Configuration file not found: {config_path}")
            raise FileNotFoundError(f"Configuration file not found: {config_path}")
        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)
            logger.debug(f"Successfully loaded config from: {config_path}")
            return config.get('simulation_defaults', {}) # Only load the 'simulation_defaults' section
        except yaml.YAMLError as e:
            logger.error(f"Error parsing YAML config file {config_path}: {e}")
            raise

    def compile_world(self, world_rules: GeneratedWorldRules) -> Dict[str, Any]:
        """
        Compiles the generated world rules into a structured simulation configuration.

        This involves:
        1. Starting with the generic simulation settings.
        2. Populating/overriding these settings with the specific rules and parameters
           generated by the RuleGenerator.
        3. Structuring the output into a clear, hierarchical format.

        Args:
            world_rules (GeneratedWorldRules): The abstract rules designed by the AI.

        Returns:
            Dict[str, Any]: A dictionary representing the complete simulation configuration.
        """
        logger.info(f"Compiling world configuration for: {world_rules.world_name}")

        # Start with a deep copy of default settings to avoid modification issues
        compiled_config = json.loads(json.dumps(self.simulation_settings)) # Deep copy with JSON trick

        # --- Populate General World Metadata ---
        compiled_config['world_metadata'] = {
            'name': world_rules.world_name,
            'creation_timestamp': world_rules.creation_timestamp,
            'axioms_influencing_design': world_rules.axioms_used_ids,
            'designed_by': "Ontological Playground Designer AI (NeuralBlitz v50.0 Inspired)",
            'generation_meta': world_rules.meta_data
        }

        # --- Aggregate Generated Rules by Type/Category ---
        # This creates a structured representation of the rules for the simulator.
        # The specific structure here depends on the target simulator's expected format.
        # For this example, we'll categorize them as 'agent_rules', 'environment_rules', etc.
        
        compiled_config['generated_world_rules'] = {
            'agent_behaviors': [],
            'environmental_laws': [],
            'resource_mechanics': [],
            'social_dynamics': [],
            'system_mechanics': [],
            'meta_rules': [],
            'unclassified_rules': [] # Catch-all for new rule types
        }

        for rule in world_rules.rules:
            rule_entry = {
                'id': rule.id,
                'description': rule.description,
                'parameters': rule.parameters,
                'dependencies': rule.dependencies, # Simulator can use this to resolve execution order
                'axiom_influence': rule.axiom_influence,
                'logical_form': rule.logical_form # For advanced simulators that can interpret formal logic
            }
            
            # Categorize rules for easier simulator parsing
            if rule.type == "agent_behavior":
                compiled_config['generated_world_rules']['agent_behaviors'].append(rule_entry)
            elif rule.type == "environmental_law":
                compiled_config['generated_world_rules']['environmental_laws'].append(rule_entry)
            elif rule.type == "resource_mechanic":
                compiled_config['generated_world_rules']['resource_mechanics'].append(rule_entry)
            elif rule.type == "social_dynamic":
                compiled_config['generated_world_rules']['social_dynamics'].append(rule_entry)
            elif rule.type == "system_mechanic":
                compiled_config['generated_world_rules']['system_mechanics'].append(rule_entry)
            elif rule.type == "meta_rule":
                compiled_config['generated_world_rules']['meta_rules'].append(rule_entry)
            else:
                compiled_config['generated_world_rules']['unclassified_rules'].append(rule_entry)
        
        logger.debug(f"Categorized {len(world_rules.rules)} rules.")

        # --- Override/Update Initial Simulation Defaults with Generated Parameters ---
        # The rule generator might output values for global parameters.
        # This is a simplified example; a real system would have explicit mappings.
        for rule in world_rules.rules:
            if "Resource_Regen" in rule.id and "regen_health_multiplier" in rule.parameters:
                compiled_config['base_resource_regen_rate'] = rule.parameters['regen_health_multiplier'] # Example override
            # More complex logic would be needed here to map rules to global defaults
        
        # --- Add Rule Graph (for advanced simulators or visualization tools) ---
        # The rule_graph is a NetworkX object, which isn't directly JSON serializable.
        # We convert it to a simpler, serializable format (e.g., list of edges with node attributes).
        if world_rules.rule_graph:
            compiled_config['rule_interdependencies_graph'] = {
                'nodes': [{'id': node_id, 'attributes': data} for node_id, data in world_rules.rule_graph.nodes(data=True)],
                'edges': [{'source': u, 'target': v, 'attributes': data} for u, v, data in world_rules.rule_graph.edges(data=True)]
            }
            logger.debug("Converted rule graph for serialization.")


        logger.info(f"Successfully compiled world configuration for: {world_rules.world_name}")
        return compiled_config

    def save_world_config(self, compiled_config: Dict[str, Any], output_path: str, format: str = "json"):
        """
        Saves the compiled world configuration to a file.

        Args:
            compiled_config (Dict[str, Any]): The complete simulation configuration.
            output_path (str): The directory to save the file in.
            format (str): The desired output format ("json" or "yaml").
        """
        world_name = compiled_config['world_metadata']['name']
        filename = os.path.join(output_path, f"{world_name}.{format}")

        os.makedirs(output_path, exist_ok=True)

        try:
            if format == "json":
                with open(filename, 'w') as f:
                    json.dump(compiled_config, f, indent=4)
            elif format == "yaml":
                with open(filename, 'w') as f:
                    yaml.dump(compiled_config, f, indent=4, sort_keys=False) # sort_keys=False for better readability of rules
            else:
                logger.error(f"Unsupported output format: {format}. Only 'json' and 'yaml' are supported.")
                raise ValueError("Unsupported output format")
            logger.success(f"World configuration saved to: {filename}")
        except Exception as e:
            logger.error(f"Failed to save world configuration to {filename}: {e}")
            raise

# --- Example Usage (for testing and demonstration) ---
if __name__ == "__main__":
    # Ensure config directory and necessary files exist for testing
    if not os.path.exists("config"):
        os.makedirs("config")
    if not os.path.exists("data/generated_worlds"):
        os.makedirs("data/generated_worlds")
    
    # Create dummy config/model_config.yaml (needed by RuleGenerator)
    model_config_path = "config/model_config.yaml"
    if not os.path.exists(model_config_path):
        dummy_model_config = {
            'rule_generator_model': {
                'type': "GraphTransformer",
                'architecture': {},
                'hyperparameters': {},
                'input_processing': {
                    'axiom_embedding_model': "sentence-transformers/all-MiniLM-L6-v2"
                },
                'output_constraints': {
                    'max_rule_complexity_score': 0.8
                }
            }
        }
        with open(model_config_path, 'w') as f:
            yaml.safe_dump(dummy_model_config, f)
        logger.info(f"Created dummy {model_config_path} for testing.")

    # Create dummy config/simulation_settings.yaml
    sim_settings_path = "config/simulation_settings.yaml"
    if not os.path.exists(sim_settings_path):
        dummy_sim_settings = {
            'simulation_defaults': {
                'simulation_engine_version': "generic_agent_based_v1.0",
                'initial_world_size': {'x_dim': 100, 'y_dim': 100, 'z_dim': 1},
                'time_step_duration_ms': 100,
                'max_simulation_steps': 50000,
                'output_format': "JSON"
            }
        }
        with open(sim_settings_path, 'w') as f:
            yaml.safe_dump(dummy_sim_settings, f)
        logger.info(f"Created dummy {sim_settings_path} for testing.")

    # Create a dummy axioms.yaml if not present (needed by AxiomParser and RuleGenerator)
    axiom_file_path = "config/axioms.yaml"
    if not os.path.exists(axiom_file_path):
        dummy_axioms = {
            'world_axioms': [
                {'id': 'PHILOSOPHY_FLOURISHING_001', 'principle': 'Maximize well-being and adaptive capacity.', 'priority': 1, 'type': 'ethical'},
                {'id': 'ECOLOGY_SUSTAINABILITY_001', 'principle': 'Ensure perpetual resource sustainability and regeneration.', 'priority': 2, 'type': 'environmental'},
            ]
        }
        with open(axiom_file_path, 'w') as f:
            yaml.safe_dump(dummy_axioms, f)
        logger.info(f"Created dummy {axiom_file_path} for testing.")
    
    # Ensure src/utils/logger.py exists for setup_logging
    if not os.path.exists("src/utils"):
        os.makedirs("src/utils")
        # Assuming logger.py is already there from axiom_parser.py's __main__ block

    from src.core.axiom_parser import AxiomParser
    from src.core.rule_generator import RuleGenerator

    # 1. Parse Axioms
    axiom_parser = AxiomParser(model_config_path=model_config_path)
    axiom_set = axiom_parser.parse_axioms(axiom_file_path)

    # 2. Generate Rules (using the simulated logic)
    rule_generator = RuleGenerator(model_config_path=model_config_path, 
                                   simulation_settings_path=sim_settings_path)
    world_rules = rule_generator.generate_rules(axiom_set, "MyCompiledOntologicalWorld")

    # 3. Compile World
    world_compiler = WorldCompiler(simulation_settings_path=sim_settings_path)
    compiled_world_config = world_compiler.compile_world(world_rules)

    # 4. Save World Configuration
    output_directory = "data/generated_worlds"
    world_compiler.save_world_config(compiled_world_config, output_directory, format="json")

    logger.info(f"\n--- Successfully compiled and saved '{compiled_world_config['world_metadata']['name']}.json' ---")
    # You can inspect the generated JSON file in data/generated_worlds/
